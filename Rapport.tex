\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{fancyvrb}
\usepackage{verbatim}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{todonotes}

% Title Page
\title{Développement d'un environnement pour algorithmes distribués sur Android}
\author{Célia Dehors, Vincent Durand, Justine Romero}
\date{Année 2017-2018}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\makeatletter
\newskip\@bigflushglue \@bigflushglue = -100pt plus 1fil
\def\bigcenter{\trivlist \bigcentering\item\relax}
\def\bigcentering{\let\\\@centercr\rightskip\@bigflushglue%
\leftskip\@bigflushglue
\parindent\z@\parfillskip\z@skip}
\def\endbigcenter{\endtrivlist}
\makeatother

\titleformat{\chapter}[hang]{\bf\huge}{\thechapter}{2pc}{}

\begin{document}  
  \begin{titlepage}
    \centering
    \vspace*{0.5 cm}
    \includegraphics[scale = 0.05]{logo_univ.png}\\[1.0 cm]   % University Logo
    \LARGE Université de Franche-Comté\\[2.0 cm]   % University Name
    \Large Rapport de Projet Semestriel\\               % Course Code
    \large Master Informatique, 2ème année\\[2.5 cm]               % Course Name
    \rule{\linewidth}{0.2 mm} \\[2.5 mm]
    { \huge \bfseries \thetitle}\\
    \rule{\linewidth}{0.2 mm} \\[2.0 cm]
    
    \begin{minipage}{0.6\textwidth}
        \begin{flushleft} \large
            \emph{Étudiants:}\\
            \theauthor
        \end{flushleft}
    \end{minipage}~
    \begin{minipage}{0.4\textwidth}
        \begin{flushleft} \large
            \emph{Tuteur:}\\
            M. Laurent PHILIPPE
        \end{flushleft}
    \end{minipage}\\[3.0 cm]
    {\large \thedate}\\[2 cm]
    \vfill
    
\end{titlepage}
\chapter*{Remerciements}
\paragraph{}
Nous tenons à adresser nos sincères remerciements à plusieurs personnes qui nous ont aidées à la réalisation de ce projet ainsi qu'à l'élaboration de ce mémoire.

En premier lieu nous remercions M. Laurent Philippe, notre tuteur, pour son aide dans les choix que nous avons eu à prendre, et pour le temps qu'il nous à consacré tout au long de ce projet.

Nous remercions également les personnes qui nous ont aidés à la relecture du mémoire.

Enfin nous tenons à remercier Udacity et Google pour le Google Developer Challenge Scholarship, une formation Android qui a été mise à disposition de certains membres du groupe.
%Table des matières
\begin{changemargin}
\tableofcontents
\end{changemargin}
\chapter*{Glossaire}
\todo{A remplir}

\chapter{Introduction}
\sloppy
  \paragraph{}
  Différents projets ont été proposés aux étudiants de deuxième année de Master pour cette année 2018. Dans notre cas nous avons choisi le sujet suivant : "Développement d’un environnement pour les algorithmes distribués sur Android".
  \paragraph{}
  Ce projet nous a intéressé car il mélangeait différents domaines appréciés par les membres de notre trinôme soit la synchronisation distribuée et le développement Android.
  L'aspect distribué permet aux utilisateurs d'avoir leur application sur leur téléphone qui partage des données avec les autres terminaux mobiles inter-connectés.
  \paragraph{}
  Quelles sont les solutions et les méthodes que nous avons appliquées pour réaliser ce projet ?
  \paragraph{}
  Ce rapport se compose de cinq grands axes. Nous étudions tout d'abord le sujet du projet en détail puis nous développons les recherches préliminaires au développement. 	Par la suite nous présentons les outils de développement utilisés puis décrivons l'architecture du projet avec ses différentes couches d'implémentation. Enfin nous expliquons l'algorithme que nous voulons implémenter afin de tester les fonctionnalités crées.

\chapter{Présentation du projet}
  \section{Sujet}
  \paragraph{}
  L’objectif de ce projet est de réaliser un environnement d’exécution et de communication
  sur des appareils Android pour permettre le développement et la démonstration
  d’algorithmes distribués. L’environnement devra permettre l'écriture simple des algorithmes
  et la réalisation de démonstrations pour simplifier leur compréhension.
  \paragraph{}
  Le travail consiste donc à réaliser une plateforme qui permette de programmer facilement un algorithme
  distribué et de pouvoir le dérouler tout en observant les échanges de messages et
  le contenu des variables.
  Les algorithmes pourront ensuite servir pour implanter des applications simples comme
  des jeux. 
  \paragraph{}
  Le travail sera réalisé avec Java sous Android.
  
  \section{Problématiques}
  \paragraph{}
  Après la première réunion de travail avec notre tueur, nous avons pu identifier les problématiques posées par notre projet, qui sont les suivantes :
\paragraph{}
  \begin{itemize}
    \item Quelles sont les technologies dont nous disposons pour faire communiquer nos appareils Android ensemble ?
    \newline
    \item Quelle architecture d'application allons-nous mettre en place pour faciliter l'usage de celle-ci (rédaction des algorithmes distribués) pour l'utilisateur final ?
    \newline
    \item Comment pouvons-nous proposer un outil simple d'utilisation en masquant les aspects techniques de la communication entre appareils ?
  \end{itemize}
  
  
\chapter{Recherche des technologies de communication}
  \paragraph{}
  L'objectif de ce projet est la réalisation d'un environnement d'exécution et de communication permettant le développement et la démonstration d'algorithmes distribués sur des appareils Android. Notre travail consiste donc au développement d'une application Android possédant son propre système de communication et capable de faire exécuter divers algorithmes.
  Notre travail se découpe en plusieurs phases :
  La première est l'étude des différentes technologies de communications disponibles sur les appareils Android.
  La deuxième est l'implémentation du système de communication dans la technologie choisie.
  La troisième est la mise en place d'une API permettant aux développeurs de mettre en place les algorithmes souhaités, en l'occurence des algorithmes distribués, sur l'application créée.
  Afin de compléter l'étude des différentes technologies et confirmer notre choix, nous avons décidé de développer en parallèle plusieurs applications supportant chacune une des technologies de communication. Ceci afin de pouvoir comparer les performances de chacune des technologies ainsi que leurs limites et leur souplesse.
  \section{Bluetooth}
    \subsection{Historique}
    \subsection{Fonctionnement} \todo{pap}
    \subsection{Avantages}
    \subsection{Inconvénients}
  \section{Wifi Direct}
    \subsection{Historique}
      \paragraph{}
      Créé par la Wifi Alliance, le Wifi Direct permet le partage de données entre différents appareils grâce à leur connexion Wifi sans avoir besoin d'une liaison avec d'un point d'accès intermédiaire.
    \subsection{Fonctionnement}
     \paragraph{}
    L'activation du Wifi Direct sur les appareils ne nécessite d'activer qu'une option dans les paramètres du Wifi, grâce aux options avancés. Une fois ceci fait, l'envoi des fichiers est possible.
    \paragraph{}
    Si la technologie n'est pas activée au lancement d'une application, il est possible de mettre en place une autorisation d'activation dans le code afin de mettre en marche le Wifi Direct. En revanche ce n'est utilisable que sur des dispositifs sous Android 2.3 minimum.
    \subsection{Avantages}
     \paragraph{}
     L'avantage principal de l'utilisation du Wifi Direct est la vitesse d'envoi des fichiers entre les appareils, surtout lorsque de lourds fichiers sont en jeu. 
     Il est aussi possible d'utiliser cette technologie entre différents types de dispositifs, entre autres : smartphones, télévisions, ordinateurs, tablettes. Cela permet une utilisation large des applications grâce à une connectivité plus simple et plus rapide que le Bluetooth. Un autre avantage est la compatibilité : tout appareil utilisant le Wifi classique sera en mesure de répondre à une communication avec un dispositif utilisant le Wifi Direct.
    \subsection{Inconvénients}
    \paragraph{}
    D'après certains retours, l'activation du Wifi Direct peut entraîner des soucis sur certains modèles de télépones et de tablettes. De plus certains dispositifs ne fonctionnent qu'avec des appareils de la même marque, ce qui complique la mise en place d'un algorithme distribué.
    L'écriture du code du Wifi Direct n'est pas aisée à cause du manque de documentation et du fait que cette technologie n'est pas encore très répendue.
  \section{NFC}
    \subsection{Historique}
     \paragraph{}
     Le NFC ou Near Field Communication est une technologie de communication radio. Elle est apparue en 1994 et nous est encore utile aujourd'hui dans les téléphones (paiement mobile) par exemple.
    \subsection{Fonctionnement}
     \paragraph{}
     Le NFC permet l'échange d'informations sur de très courtes distances [1]. Il permet de se faire passer pour une carte à puce face à un lecteur, de faire office de terminal pour lire des cartes, mais possède également un mode pair à pair pour l'échange d'informations entre deux terminaux mobiles. C'est ce mode qui nous intéressait.
    \subsection{Avantages}
    \paragraph{}
    Le NFC dispose de certains avantages comme d'une vitesse de transfert pouvant aller jusqu'à 424kbit/s [2] (une grande valeur sachant que la taille des messages envoyés est d'une dizaine d'octet) et d'un mode de communication full duplex permettant des échanges dans les deux sens en même temps.
    \subsection{Inconvénients}
    \paragraph{}
    Le principal inconvénient de cette technologie est la distance, en effet elle ne fonctionne qu'avec un espacement de quelques centimètres entre les deux terminaux.
  \section{Choix de la technologie}
  
  Afin de prendre une décision sur la technologie a utiliser pour l'application, des comparatifs ont été réalisés en mettant en avant les avantages et les inconvénients de chacune. 
  \paragraph{}
  En ce qui concerne le NFC, il a été décidé de ne pas retenir cette solution en raison de la faible distance requise entre deux appareils pour son fonctionnement (environ 10cm maximum).
  \paragraph{}
  Pour départager le Bluetooth et le Wifi Direct, il a été décidé de développer deux applications utilisant chacune une des technologies et de les comparer directement grâce aux implémentations réalisées.
  \paragraph{}
  Concernant le Bluetooth, l'avancée de l'application était plutôt rapide, grâce à des tutoriels Android mis à disposition par Google. Cependant pour le Wifi Direct, l'écriture du code a été plus compliquée à réaliser, lorsque des erreurs étaient rencontrées lors de l'écriture de l'application, il était difficile de savoir d'où provenait le problème. Est-ce qu'il était dû à la marque du téléphone ? Ou à une erreur de code ? 
  \paragraph{} 
  L'application Bluetooth étant terminée et fonctionnelle contrairement à celle utilisant le Wifi, il a donc été décidé pour une bonne avancé du projet de choisir la première option pour notre application.
  
%   \section{Comparaison Bluetooth/Wifi} \todo{virer cette partie}
%     \paragraph{}
%     Notre première étape est l'étude des différentes technologies disponibles. Notre attention se porte sur deux technologies principales bien connues : Bluetooth et Wifi.
%     Nous recherchons tout d'abord des informations sur le web.
%     Wifi semble être davantage adapté à notre usage. Il est plus rapide, stable, fiable, accepte plus de connexions.
%     Bluetooth est quant à lui plus léger.
%     Puis afin d'avoir une comparaison plus tangible des deux technologies, nous décidons d'implémenter deux applications distinctes utilisant chacune une des technologies. Cela dans le but de comparer autant les performances/limites des technologies que leur facilité de mise en place.
%     -> Conclusion
%     L'implémentation du Bluetooth est bien plus rapide que celle du wifi, la documentation est plus simple et plus accessible. Nous essayons d'implémenter le wifi mais le temps passant, nous préférons partir sur le bluetooth qui fonctionne déjà.

\chapter{Outils de développement}
  \paragraph{}
  Utilisation d'Android Studio et versionnement des sources avec un serveur gitlab.
  \section{Android Studio}
  Nous devions développer sous Android et avons donc eu le choix entre plusieurs IDE (Android Studio, Eclipse). S'étant familiarisés avec les outils JetBrains pendant notre cursus c'est tout naturellement que notre choix s'est porté sur Android Studio. De plus, depuis 2014, cet IDE est devenu l'outil officiel de Google pour le développement android.
  \section{Gitlab}
  \todo{A toi de jouer Celia}
  %besoin de versionner
  %on disposait de serveurs gitlab chez nous

\chapter{Développement de l'architecture de l'application}
\todo{dire pourqoi on a choisit ça en fonction des besoins de production qu'on avait}
  \paragraph{}
  Dans cette partie nous allons présenter la façon dont l'application a été conçue et expliquer le fonctionnement de celle-ci. L'application a été architecturée en plusieurs couches pour introduire plusieurs niveaux d'abstraction, séparer les rôles et simplifier le développement.
  
  \section{Couche bas niveau}
    \paragraph{}
    La couche bas niveau de notre application permet la communication entre plusieurs appareils et va servir de support à l'implémentation des algorithmes distribués. Elle est constituée des mécaniques de connexion, de routage et d'échange de paquets sur le réseau afin de permettre une mise en place simple des algorithmes. C'est elle qui a été conçue en premier car elle est le soubassement de toutes les fonctionnalités de notre application.
  
    \subsection{Fonctionnement de base}
    \paragraph{}
    La première pierre de l'édifice est la création d'un service Bluetooth central qui va être le garant du bon fonctionnement des échanges entre appareils. C'est lui qui va permettre d'activer ou désactiver la connexion Bluetooth de l'appareil, qui va décider si l'on se rend visible sur le réseau ou non mais surtout de rechercher des appareils disponibles et se connecter à eux pour ensuite communiquer ensemble.
    
    \subsection{Connexion}
    \paragraph{}
    La connexion en Bluetooth entre plusieurs appareils nécessite la création d'un UUID. Un UUID est un identifiant unique composé de 128 bits. Sa taille est telle que l'on considère qu'il n'est pas possible d'avoir de collision en choisissant un UUID au hasard. Dans notre application, cela va permettre de ne pas tenter de se connecter à un appareil qui serait visible en Bluetooth mais qui n'utiliserait pas l'application, et qui par conséquent n'est pas souhaité dans notre réseau.
    Pour qu'une connexion soit réalisée en Bluetooth il est nécessaire d'avoir un client et un serveur. Le serveur va ouvrir une socket sur laquelle le client va venir initier une connexion à partir de l'adresse MAC du serveur.
    La connexion entre plusieurs appareils est gérée par le service Bluetooth. Chaque appareil peut être indistinctement client ou serveur. Pour cela, les mécanismes de connexions sont divisés en deux threads : un thread ayant le rôle de serveur et un thread ayant le rôle de client.
    Lorsque qu'un client et un serveur se sont connectés, un canal RFCOMM est créé permettant la communication des deux appareils, chacun pouvant lire et écrire sur la socket correspondant à la connexion indistinctement du rôle qu'il a joué lors de la phase de connexion.
    
    \subsection{Communication}
    \paragraph{}
    Le mécanisme de communication est implémenté dans un nouveau thread pour permettre le maintien de plusieurs connexions simultanées. Ce thread va constamment attendre qu'un flux de données arrive en entrée sur la socket. Il va bien évidemment aussi être capable d'écrire sur cette socket.
    Tous les messages échangés adoptent la même forme : un expéditeur, un destinataire et le contenu du message constitué lui-même d'un octet correspondant au type de message et d'un tableau d'octets correspondant aux données du message. Le type de message peut être soit un type de message de bas niveau permettant la mise en place des mécanismes de bas niveau de la communication soit un type de message correspondant aux messages de l'algorithme distribué implémenté.
    Lors de la réception d'un message sur la socket, nous récupérons le type de message envoyé et effectuons les traitements adpatés en fonction de celui-ci.
    
    \subsection{Routage}
    \paragraph{}
    La mécanique de bas niveau la plus complexe et sophistiquée est le routage. C'est lui qui va permettre à des appareils qui ne sont pas connectés directement de pouvoir tout de même communiquer entre eux. Cela est nécessaire du fait de la faible portée du Bluetooth afin de pouvoir faire partie du réseau sans pour autant être à portée de tous les autres appareils du réseau.
    
    //table de routage
    //gestion des entrées de la table
    //recherche de chemin vers
    //communication avec un appareil distant
  
  \section{Couche intermédiaire}
    \subsection{Implémentation d'un anneau}
    \paragraph{}
    Afin de permettre l'implémentation d'algorithmes à base d'anneau, nous avons souhaité mettre en place un anneau. Nous avons tout d'abord tenté de construire un anneau dans la couche haute de l'application, au niveau développeur, mais la construction d'un anneau à ce niveau était complexe notemment au niveau de l'initiation de la construction de l'anneau. Nous avons alors décidé qu'il serait plus simple de créer l'anneau dans une couche plus basse, juste au-dessus de la couche de routage, de façon systématique, quitte à ce que l'anneau ne soit pas utilisé par le développeur.
    
      \subsubsection{Création de l'anneau}
      \paragraph{}
      La création de l'anneau est donc réalisée en même temps que la connexion à un appareil. Lorsqu'un appareil se connecte au réseau, il demande à être inséré dans l'anneau du serveur. Plusieurs cas différents s'appliquent. Soit cette connexion est la première connexion du réseau, un anneau est donc créé avec l'appareil initial et le nouvel appareil, chacun étant le suivant de l'autre. Soit la connexion concerne un nouvel appareil qui s'implante dans un anneau déjà construit, auquel cas l'appareil est inséré dans l'anneau par son serveur. Soit la connexion est faite entre deux appareils qui se trouvent chacun déjà dans un anneau, ce qui peut amener à une fusion des anneaux.
      
      \subsubsection{Insertion dans un anneau}
      \paragraph{}
      Lorsqu'un nouvel appareil se connecte au réseau, il doit être inséré dans l'anneau. Ce qui se passe est que l'appareil qui a accepté la connexion va envoyer son suivant au nouvel appareil et garder le nouvel appareil comme suivant.
      
      \subsubsection{Fusion des anneaux}
      \paragraph{}
      Lorsque deux appareils se connectent entre eux tout en faisant chacun déjà partie d'un réseau, deux cas sont possibles. Dans la majorité des cas, cette connexion est réalisée par deux appareils faisant partie du même réseau, lors de la phase de construction d'un réseau complet. Dans ce cas aucune modification n'a besoin d'être effectué sur l'anneau : celui-ci est déjà construit et contient déjà les deux appareils. Cependant dans une petite minorité des cas, il est possible que les deux appareils fassent chacun partie d'un réseau distinct. Cela se produit lorsque deux réseaux éloignés spacialement se rapprochent et que deux appareils se retrouvent dans la portée Bluetooth. Dans ce cas deux anneaux distincts sont construits, il est alors nécessaire de les fusionner. 
      
  \section{Couche haut niveau}
    \subsection{API sur le modèle de Visidia}
    \paragraph{}
    Afin de pouvoir utiliser les couches de niveau inférieur de l'application, une API a été développée et réalisera le lien avec les algorithmes qu'un développeur voudra mettre en place.
    Elle permet d'envoyer des messages entre différents appareils et la réception de ceux-ci. L'implémentation de l'API a été réalisée en suivant le modèle utilisé par le logiciel Visidia étudié en module de Synchronisation Distribuée durant ce semestre de Master. Des fonctions ont été créées afin de permettre l'utilisation des informations de la table de routage permettant la communication avec d'autres appareils.
    
    \subsection{Algorithmes} \todo{Implémentabilité}
%   \section{Fonctionnalités de base / connexion}
%     \paragraph{}
%     Création d'un UUID afin d'identifier les connexions Bluetooth
%     Ajout des threads pour les rôles de client, de serveur, et de gestion de connexions. \todo{expliquer les Fonctionnalités des threads}
%     Ajout d'une Fonctionnalité pour activer/désactiver le bluetooth depuis l'application sans devoir passer par les paramètres système
%     Refactoring pour déplacer les morceaux de codes dans des petites fonctions afin de rendre le code plus lisible et mieux maintenable
%     Ajout d'un menu proposant les options de se rendre visible sur le réseau, de découvrir les appreils visibles, de se rendre disponible en tant que serveur (avec le UUID) ou de se connecter à un serveur
    
    
%     S'appairer/se connecter à deux puis plus
%     Mode serveur : accepter une connexions
%     Mode client : se connecter à un serveur
%     Mise en place de la connexion (stream entre deux device)
%     L'architecture du service Bluetooth est la suivante : une classe principale BluetoothService composée d'une interface regroupant les types de messages échangés à bas niveau (lecture, écriture, connexion, déconnexion et mécanismes de fonctionnement de la couche basse de l'application) et trois threads permettant l'interconnexion des appareils. Nous avons un thread serveur permettant d'accepter des connexions entrantes, un thread client permettant de se connecter sur un serveur et un thread de connexion établie permettant d'envoyer et de recevoir des messages entre deux appareils connectés.
    
%   \section{Fonctionnalités de communication/ couche basse comm}
%     \paragraph{}
    
%     Envoi de message texte
%     Mise en place routage, sérialisation
%     explication des formats de messages MessagePacket, type et byte[] data
    
%   \section{Couche intermédiaire}
%     \paragraph{}
%     Implémentation des types de messages
%     Implémentation d'un token ring
%       -> réflexion implémentation d'un token ring au niveau api puis implémentation réelle à bas niveau
    
%   \section{Couche haute API algos}
%     \paragraph{}
    
  \subchapter{Développement d'une API permettant de créer des algos distribués}
  \paragraph{}

\chapter{Algorithme distribué implémenté}
\paragraph{}
Afin de démontrer les fonctionnalités de l'application, nous avons réalisé un algorithme distribué ayant pour but la gestion d'un chat entre plusieurs téléphones mobiles. L'écriture dans le chat représente la section critique (deux appareils ne doivent pas pouvoir écrire \todo{pas plutôt envoyer ? parce que empêcher d'écrire je pense pas que ça va être possible, ni intéressant} en même temps).

Le principe de l'algorithme est le suivant : lorsqu'une personne souhaite écrire dans le chat elle clique sur le bouton "Demander l'accès" puis attend la notification d'accès.
Elle peut écrire autant qu'elle veut.
Quand elle à fini d'écrire il lui suffit de cliquer sur le bouton "fin de transmission" pour libérer la section critique et permettre à quelqu'un d'autre de prendre la main.

Pour gérer la synchronisation des demandes nous avons choisi d'implémenter l'algorithme de Lamport avec estampilles ce qui nous permet de gérer les demandes concurrentes grâce à la datation logique. Ce n'est pas le plus optimisé des algorithmes à estampille mais cela est suffisant pour un exemple de fonctionnement.

\chapter{Déroulement du projet}
 \section{Partage des tâches}
 \paragraph{}
 Dans ce projet chacun avait des affinités, Celia par exemple est douée en développement android c'est donc elle qui s'est chargée de la création de l'application et de la majeure partie du développement. Justine quand à elle à une bonne vision du fonctionnement de l'outil ainsi qu'un bon esprit de synthèse elle s'est donc occupée de la création de l'API et des fonctions dites "haut niveau" qui facilitent l'utilisation de l'application. Vincent préfère la partie théorique et la modélisation algorithmique, il a donc été actif lors des discussions sur les choix d'implémentations lors des réunions de groupe et a développé l'algorithme de test.
 \section{Rétrospective sur le travail d'équipe}
 \paragraph{}
 Le travail d'équipe s'est bien réparti, chacun avait ses taches à réaliser que ce soit de la recherche, du développement ou encore de la modélisation. Toute l'équipe participait activement aux discussions lorsqu'il y avait des décisions à prendre.

\chapter{Conclusion}
\section{État d'avancement}
\paragraph{}
A ce jour nous avons une application qui gère un nombre non limité d'appareils interconnectés simultanément. Nous pouvons nous connecter à un réseau existant à n'importe quel moment et être connu de tous.
\paragraph{}
Nous disposons aussi d'une API permettant le développement d'algorithmes distribués. Cette API peut être complétée si de nouveaux besoins sont découverts lors de l'utilisation de notre outil.
\paragraph{}
Nous avons cependant pris du retard sur l'implémentation de l'algorithme de démonstration qui est écrit mais pas utilisable directement dans l'application.
\paragraph{}
\section{difficultés rencontrées}
\paragraph{}
La principale difficulté que nous avons eue est la découverte du fonctionnement d'Android, c'est à dire comprendre l'architecture et l'articulation de toutes les parties d'une application. C'est en partie du à cela que nous n'avons pas pu mettre mettre en place l'algorithme.
\todo{ajouter les difficultés}
\chapter*{Bibliographie}
\todo{Mettre en page}
\sloppy
 NFC :
 
 [1]https://fr.wikipedia.org/wiki/Communication_en_champ_proche
 (18/10/2017)
 
 [2]http://www.blog-crm.fr/exposes-etudiants/technologie-nfc/
 (15/10/2017)
 
 
\newline
 Wifi-Direct :

 [3]http://www.techradar.com/news/phone-and-communications/mobile-phones/wi-fi-direct-what-it-is-and-why-you-should-care-1065449 (16/10/2017)
 [4]https://www.androidpit.com/what-is-wifi-direct (16/10/2017)
 [5]https://stackoverflow.com/questions/11251610/wifi-direct-android-4-0-with-multiple-3-devices (16/10/2017)
 [6]http://www.thinktube.com/tech/android/wifi-direct (08/11/2017)
 
 \paragraph{}
 Bluetooth :

 [7]http://www.phonandroid.com/bluetooth-google-fast-pair-systeme-simplifier-appairage-smartphone.html (31/10/2017)
 
 \chapter*{Résumé}
 Dans le cadre du Master Informatique de l'Université de Franche-Comte, les étudiants ont comme mission de réaliser un projet tuteuré. Ce rapport vous présentera notre projet de développement d'une application Android permettant la création et exécution d'un algorithme distribué.
 
 Ce rapport présentera le sujet et ses problématiques, la conception et la réalisation du dit projet.
 
 La technologie utilisée pour la communication est le Bluetooth ce qui nous permet de construire un grand réseau de communication inter appareils sans limite de nombre.
 
 Programmé en Java \todo{Ajouter la version} pour des appareils Android version \todo{AJOUTER LA VERSION ANDROID}
 
 Mots-clés : Android, Bluetooth, Wifi-Direct, NFC, Algorithme distriué, Visidia \todo{Parler de visidia qqpart}
 
 \chapter*{Abstract}
 \todo{Doit être sur la même page que le résumé
 }
\end{document}          
